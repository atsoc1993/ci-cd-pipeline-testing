#pragma version 11
#pragma typetrack false

// algopy.arc4.ARC4Contract.approval_program() -> uint64:
main:
    intcblock 1 0
    bytecblock "global_counter"
    txn ApplicationID
    bnz main_after_if_else@2
    // contract.py:18
    // self.global_counter = arc4.UInt64(0)
    bytec_0 // "global_counter"
    pushbytes 0x0000000000000000
    app_global_put

main_after_if_else@2:
    // contract.py:16
    // class TestContract(ARC4Contract):
    txn NumAppArgs
    bz main___algopy_default_create@7
    pushbytes 0x0df58de0 // method "create_box(pay)void"
    txna ApplicationArgs 0
    match main_create_box_route@5
    err

main_create_box_route@5:
    // contract.py:21
    // @abimethod
    txn OnCompletion
    !
    txn ApplicationID
    &&
    assert // OnCompletion must be NoOp && can only call when not creating
    b create_box

main___algopy_default_create@7:
    txn OnCompletion
    !
    txn ApplicationID
    !
    &&
    assert // OnCompletion must be NoOp && can only call when creating
    intc_0 // 1
    return


// contract.TestContract.create_box[routing]() -> void:
create_box:
    // contract.py:21
    // @abimethod
    txn GroupIndex
    intc_0 // 1
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    // contract.py:7
    // return Global.current_application_address.min_balance
    global CurrentApplicationAddress
    acct_params_get AcctMinBalance
    assert // account funded
    // contract.py:24
    // self.test_box_map[Txn.sender] = self.global_counter
    intc_1 // 0
    bytec_0 // "global_counter"
    app_global_get_ex
    assert // check self.global_counter exists
    txn Sender
    dig 1
    box_put
    // contract.py:31
    // self.global_counter = arc4.UInt64(self.global_counter.as_uint64() + 1)
    btoi
    intc_0 // 1
    +
    itob
    bytec_0 // "global_counter"
    swap
    app_global_put
    // contract.py:7
    // return Global.current_application_address.min_balance
    global CurrentApplicationAddress
    acct_params_get AcctMinBalance
    assert // account funded
    // contract.py:27
    // refund_excess_mbr(mbr_payment.amount - (post_mbr - pre_mbr))
    uncover 2
    gtxns Amount
    swap
    uncover 2
    -
    -
    // contract.py:11-14
    // itxn.Payment(
    //     receiver=Txn.sender,
    //     amount=excess
    // ).submit()
    itxn_begin
    // contract.py:12
    // receiver=Txn.sender,
    txn Sender
    itxn_field Receiver
    itxn_field Amount
    // contract.py:11
    // itxn.Payment(
    intc_0 // pay
    itxn_field TypeEnum
    intc_1 // 0
    itxn_field Fee
    // contract.py:11-14
    // itxn.Payment(
    //     receiver=Txn.sender,
    //     amount=excess
    // ).submit()
    itxn_submit
    // contract.py:21
    // @abimethod
    intc_0 // 1
    return
